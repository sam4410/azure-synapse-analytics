{
	"name": "Pool validation queries",
	"properties": {
		"content": {
			"query": "-- get the count of control nodes and compute nodes in synapse dedicated SQL pool\nselect * from sys.dm_pdw_nodes\nGO\nselect type, count(1)\nfrom sys.dm_pdw_nodes\ngroup by type;\n\n--view the current DWU setting\nselect db.name [Database]\n, ds.edition [Edition]\n, ds.service_objective [Service Objective]\nfrom sys.database_service_objectives AS ds\nJOIN sys.databases AS db ON ds.database_id = db.database_id;\n\n-- Dynamic Management Views (DMVs) to know more about your nodes and distributions\nselect distribution_id, pdw_node_id from sys.pdw_nodes_partitions\nGO\nselect distribution_id, pdw_nodel_id from sys.pdw_distributions\n\n-- Create a HASH distributed table\nCREATE TABLE FactSales (\n  SalesID INT IDENTITY(1, 1) NOT NULL, \n  SalesDate DATETIME NOT NULL, \n  SalesItemId INT,\n  Description VARCHAR(500)\n) WITH ( CLUSTERED INDEX (SalesID), DISTRIBUTION = \nHASH(SalesDate) );\n\n/*\ninsert into dbo.FactSales (SalesDate, SalesItemId, Description)\nvalues ('2024-03-11 02:10:18.145', 15, 'bought a notepad');\n*/\n\n/* 1. uses a hash function to distribute table rows across the available compute nodes\n2. this type of distribution is created to minimize data movement across various distributions because similar values tend to fall within the same distribution\n3. Tables that are more than 2 Gigabytes (GB) in size on disk and tables having more frequent \nINSERT, UPDATE, and DELETE operations are the best candidates for hash distributions\n*/\n\n-- Create a round robin (default distriubtion type in SQL pool)\nCREATE TABLE DimSalesItem (\n  SalesItemID INT IDENTITY(1, 1) NOT NULL, \n  Description VARCHAR(500)\n) WITH ( CLUSTERED INDEX (SalesItemID), DISTRIBUTION = ROUND_ROBIN );\n\n/*\n1. default distribution type for a table in SQL Pool is round-robin distribution, whereby \ndata is divided evenly across all the distributions\n2. Sometimes, rows need to be reshuffled when you perform joining operations on round-robin distributed tables\n3. Temporary staging tables and tables with no obvious joining key are the best candidates \nfor ROUND_ROBIN distributed tables\n*/\n\n-- Create Replicated tables\nCREATE TABLE [dbo].[DimSalesRegion] \n(\n    RegionID INT IDENTITY(1,1) NOT NULL,\n    Region VARCHAR(50) NOT NULL\n)\n    WITH ( CLUSTERED COLUMNSTORE INDEX, DISTRIBUTION = \nREPLICATE )\n\n/*\n1. Replicated tables must only be used for small dimension tables\n2. This replicates the table data across all distributions so that the data becomes local to each compute node and \naccessibility becomes easier\n3. There is no need to move the data across various compute nodes for a running query, and this \nhelps to return results very quickly\n4. Small dimension tables with a size less than 2 GB are the best candidates for replicated tables\n*/\n\n-- to check data skew for a distributed table\nDBCC PDW_SHOWSPACEUSED('dbo.FactSales');\n\n-- an example of using partitions along with distributions\nCreate table [dbo].[FactSales_new] (\n    [SalesID] int NOT NULL,\n    [OrderDateKey] int NOT NULL,\n    [CustomerKey] int NOT NULL,\n    [PromotionKey] int NOT NULL,\n    [ProductKey] int NOT NULL,\n    [SalesOrderNumber] nvarchar(20) NOT NULL,\n    [OrderQuantity] smallint NOT NULL, \n    [UnitPrice] money NOT NULL,\n    [SalesAmount] money NOT NULL\n) with (\n    CLUSTERED COLUMNSTORE INDEX,\n    DISTRIBUTION = HASH([ProductKey]),\n    PARTITION(\n        [OrderDateKey] RANGE RIGHT FOR\n        VALUES\n        (\n            20000101, 20010101, 20020101, 20030101,\n            20040101, 20050101\n        )\n    )\n);\n\n-- get details about all the nodes, distributions, and partitions\nSELECT B.distribution_id, A.pdw_node_id, A.[type] AS node_type, A.name AS node_name,\nC.partition_number,C.[rows] FROM sys.dm_pdw_nodes A\nLEFT JOIN sys.pdw_distributions B ON A.pdw_node_id=B.pdw_node_id\nLEFT JOIN sys.pdw_nodes_partitions C ON B.distribution_id=C.\ndistribution_id AND A.pdw_node_id=C.pdw_node_id\nORDER BY B.distribution_id\nGO\n\n\n\n",
			"metadata": {
				"language": "sql"
			},
			"currentConnection": {
				"databaseName": "synapsesqlpool84",
				"poolName": "synapsesqlpool84"
			},
			"resultLimit": 5000
		},
		"type": "SqlQuery"
	}
}