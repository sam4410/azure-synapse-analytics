{
	"name": "T-SQL Language support in Synapse SQL Pool",
	"properties": {
		"content": {
			"query": "/*The SELECT statement in T-SQL retrieves rows from a database and enables the selection \nof columns and rows from one or multiple tables in Azure Synapse SQL. You can use the SELECT \nstatement with WHERE, GROUP BY, HAVING, and ORDER BY clauses in dedicated and serverless SQL pools.\nThe syntax for the SELECT statement in Synapse SQL is similar to that found in Azure SQL Database \nor SQL Server.\n*/\n\n/*\nSELECT OrderDateKey, SUM(SalesAmount) AS TotalSales \nFROM FactInternetSales \nGROUP BY OrderDateKey \nHAVING OrderDateKey > 20010000 \nORDER BY OrderDateKey;\n*/\n\n--CTEs\n/*A CTE is a temporary result set that is used to simplify complex joins and subqueries\nCTEs can also be used to query hierarchical data such as an organization chart. We can \neven create CTEs in Azure Synapse SQL pools for similar operations.\nThe following code block defines a CTE that will create a temporary dataset called CTE\nwith first_name and last_name columns derived from a UserData table. The SELECT query against this \ntemporary dataset will fetch all the records\n*/\n\ninsert into dbo.UserData (registration_dttm, id, first_name, last_name, email, gender,ip_address, cc,\ncountry, birthdate, salary, title, comments)\nvalues('2021-01-10 12:15:18.333', 123, 'Manoj', 'Sharma','sharma.manoj84@yahoo.co.in','Male','10.0.10.36.0',\n'201304611451200','India','1984-06-19', 2000.5, 'Tech Lead','Null')\n\nWITH CTE (id, first_name, last_name)\nAS (\n    SELECT U.[id],\n    [first_name],\n    [last_name]\n    FROM dbo.[UserData] U\n)\nSELECT * from CTE;\n\n-- SELECT-OVER Clause\n/*\nAn OVER clause is used with some window functions.  It is used to determine the partitioning and \nordering of a set of rows before the associated window function is applied.\nThe associated window function is applied on this set of rows to compute a value as per the business \ndemand. A few of the most commonly used calculations are moving averages, cumulative aggregates, \nand running totals, among others\n*/\n\n--Ranking functions\n/*\nRanking functions are used to assign a rank to each row in a partition or set of rows and \nreturn an aggregated value for each partitioning row. Ranking functions are also known as \nwindow functions.\nWe can use RANK, DENSE_RANK, ROW_NUMBER, and NTILE ranking functions in Azure Synapse SQL.\n1. The RANK function returns 1 plus the number of ranks that come before the row in \nquestion, and it provides the same numeric values for ties.\n2.  ROW_NUMBER is used to get the temporary unique sequential number of a row \nwithin a partition of a result set. It assigns rank one for the first row and increments \nthe value by 1 for each row; even if a row has similar values, it will still get assigned \na unique number.\n3. DENSE_RANK is similar to the RANK function, with a minor difference: it assigns \nthe same rank for duplicate or similar values.\n4. The NTILE function is used to divide records into a specified number of groups, \nand each group will be assigned a rank as per the specified condition. We need to \nspecify the number of groups as a parameter value to the NTILE functionâ€”for \nexample, NTILE(2)\n*/\n\nSELECT p.FirstName, p.LastName \n    , ROW_NUMBER() OVER(PARTITION BY PostalCode ORDER BY \nSalesYTD DESC) AS \"Row Number\"\n    ,RANK() OVER (ORDER BY a.PostalCode) AS Rank  \n    ,DENSE_RANK() OVER (ORDER BY a.PostalCode) AS \"Dense Rank\"  \n    ,NTILE(4) OVER (ORDER BY a.PostalCode) AS Quartile\n     ,s.SalesYTD  \n    ,a.PostalCode  \nFROM Sales.SalesPerson AS s   \n    INNER JOIN Person.Person AS p   \n        ON s.BusinessEntityID = p.BusinessEntityID  \n    INNER JOIN Person.Address AS a   \n        ON a.AddressID = p.BusinessEntityID  \nWHERE TerritoryID IS NOT NULL AND SalesYTD <> 0;\n\n--Aggregate functions\n/*\nAggregate functions are used to perform a calculation on a set of values such that it \nreturns a single aggregated value. Aggregate functions can be used as expressions in the \nselect list of a SELECT statement or with a HAVING clause.\nT-SQL provides various aggregate functions, such as MIN, MAX, SUM, COUNT, AVG, and \nmany more.\nMost of these functions can even be used with an OVER clause to get the aggregated value \nfor each group in the returned row set.\n*/\n\nSELECT DISTINCT Name  \n       , MIN(Rate) OVER (PARTITION BY edh.DepartmentID) AS \nMinSalary\n, MAX(Rate) OVER (PARTITION BY edh.DepartmentID) AS \nMaxSalary  \n       , AVG(Rate) OVER (PARTITION BY edh.DepartmentID) AS \nAvgSalary  \n       ,COUNT(edh.BusinessEntityID) OVER (PARTITION BY edh.\nDepartmentID) AS EmployeesPerDept  \nFROM HumanResources.EmployeePayHistory AS eph  \nJOIN HumanResources.EmployeeDepartmentHistory AS edh  \n     ON eph.BusinessEntityID = edh.BusinessEntityID  \nJOIN HumanResources.Department AS d  \n ON d.DepartmentID = edh.DepartmentID  \nWHERE edh.EndDate IS NULL  \nORDER BY Name;\n\n--Analytic functions\n/*\nAnalytic functions are used in various different ways to perform calculations on the data \nstored in a Synapse SQL pool. We can use these functions to get top-N results or to perform \naggregate operations within a group. These functions can return multiple rows for each group.\nAzure Synapse SQL supports the following analytic functions:\n1.  CUME_DIST: This function can be used when you want to know the relative \nposition of a specific value within a group of values\n2.  FIRST_VALUE: We can use this function to get the first value in an ordered set \nof values.\n3.  LAG: Using the LAG function, you can access a row at a given physical offset that \ncomes before the current row.\n4.  LAST_VALUE: Similar to FIRST_VALUE, we can use the LAST_VALUE function to \nget the last value in an ordered set of values.\n5.  LEAD: Using the LEAD function, you can access a row at a given physical offset that \ncomes after the current row\n*/\n\n--Using dynamic SQL in Synapse SQL\n/*\nAlthough in most situations static SQL statements work well, there could be certain situations \nwhen we need to use dynamic SQL statements. Dynamic SQL is a programming technique applied to \nframe SQL statements at runtime.\nYou can use sp_executesql to run dynamic SQL scripts\n*/\n\nDECLARE @sql_fragment NVARCHAR(1000)='SELECT * from dbo.UserData1'\nEXECUTE sp_executesql @sql_fragment\n\n/*\nA SQL pool does not support blob data types that include both VARCHAR(MAX) and \nNVARCHAR(MAX). Because of this limitation, you may have difficulty in building a large \ndynamic SQL string; however, you can break the code into chunks and concatenate all the \nchunks together with an EXEC statement, as follows:\n*/\nDECLARE @sql_fragment1 VARCHAR(8000)=' SELECT name '\n,       @sql_fragment2 VARCHAR(8000)=' FROM sys.system_views '\n,       @sql_fragment3 VARCHAR(8000)=' WHERE name like \n''%table%''';\nEXEC( @sql_fragment1 + @sql_fragment2 + @sql_fragment3);\n\n/*\nThe preceding code block has three different SQL statements that are assigned to three \ndifferent variables: sql_fragment1, sql_fragment2, and sql_fragment3. \nIn the end, all the SQL statements are concatenated by using the + sign, and then the \nconsolidated SQL statement is executed by using an EXEC statement.\nDynamic SQL statements can be used in situations where you need to run similar SQL \nstatements multiple times with minor changes in the statement.\nHowever, GROUP BY is not supported with CUBE in an Azure Synapse SQL pool. We will \nlearn about the workarounds further on in this section.\n*/\n\n--GROUP BY options in Synapse SQL\n/*\nA GROUP BY clause is used with a SELECT statement to arrange identical data into groups.\nA GROUP BY clause can be used when we need to use aggregate functions such as SUM, \nAVG, and so on to fetch the aggregated value of a grouped set of records. GROUP BY can \nalso be used with CUBE, ROLLUP, and GROUPING SETS.\n*/\nselect Year, Make, sum(Trade_1_Actual_Cash_Value) as actual_cash_val\nfrom dbo.authenticom_sales\ngroup by Year, Make;\n\n--use GROUP BY with a HAVING clause to filter the data\nselect Year, Make, sum(Trade_1_Actual_Cash_Value) as Trade_1_Actual_Cash_Val\nfrom dbo.authenticom_sales\ngroup by Year, Make\nhaving sum(Trade_1_Actual_Cash_Value) <> 0 and Year >= 2000\norder by Year, Make;\n\n/*\ncalculate the aggregated value on individual groups and the cumulative aggregated value together, GROUP BY ROLLUP can be \nused with a SELECT statement\n*/\nselect Year, Make, sum(Trade_1_Actual_Cash_Value) as actual_cash_val\nfrom dbo.authenticom_sales\ngroup by rollup(Year, Make);\n\n--Using T-SQL loops in Synapse SQL\n/*\nAzure Synapse SQL allows you to use a WHILE loop to execute statements repeatedly, as long as the specified condition is True.\n*/\nDECLARE @i INT=1\nWHILE(@i<5)\n             BEGIN\n                        SELECT @i \n                        /*Your logic goes here*/\n                         SET @i+=1\n            END\n\n--We can control WHILE loops by inserting a BREAK keyword inside the loop\nWHILE (SELECT AVG(Trade_1_Actual_Cash_Value) FROM dbo.authenticom_sales) < 1000\nBEGIN\nUPDATE dbo.authenticom_sales\n    SET Trade_1_Actual_Cash_Value = Trade_1_Actual_Cash_Value*2\nSELECT MAX(Trade_1_Actual_Cash_Value) FROM dbo.authenticom_sales\n    IF (SELECT MAX(Trade_1_Actual_Cash_Value) FROM dbo.authenticom_sales) > 5000\n    BREAK\nEND\n\n--Creating stored procedures and views in Synapse SQL\n--Stored procedures\n/*\nA stored procedure is prepared SQL code that can be saved and reused. One important \nthing to keep in mind is that stored procedures are not precompiled in a Synapse SQL \npool. When stored procedures are executed, SQL statements are parsed, translated, and \noptimized at runtime. As with SQL Server, you can pass parameters to stored procedures \nin a SQL pool as well.\n*/\nINSERT INTO dbo.FactSales_new (SalesID, OrderDateKey, CustomerKey, PromotionKey, ProductKey, \nSalesOrderNumber, OrderQuantity, UnitPrice, SalesAmount) VALUES (3, 12013, 9, 7, 10, 'S_003', 20, 30, 600)\n\nALTER PROCEDURE Usp_samplestoredprocedure (@MinPriceCondition \nMONEY, \n                                      @MaxPriceCondition MONEY) \nAS \n  BEGIN \n      WHILE (SELECT AVG(SalesAmount)\n      FROM   dbo.FactSales_new) < @MinPriceCondition \n        BEGIN \n            UPDATE dbo.FactSales_new\n            SET SalesAmount = SalesAmount * 2 \n            SELECT MAX(SalesAmount) \n            FROM dbo.FactSales_new \n            IF (SELECT MAX(SalesAmount) \n                FROM dbo.FactSales_new) > @MaxPriceCondition \n              BREAK \n        END \n  END\n\nEXEC dbo.Usp_samplestoredprocedure\n@MinPriceCondition = 2000,\n@MaxPriceCondition = 5000;\n\nselect * from dbo.FactSales_new;\n\n/*You can consume the result set of a stored procedure with an INSERT statement in a SQL pool*/\nCreate Table #temp\n(\n    [OrderDateKey] int,\n    [SalesOrderNumber] varchar(20),\n    [Avg_SalesAmount] money\n)\nGO\nCreate PROCEDURE SP_ResultSet\nAS\nselect OrderDateKey,\nSalesOrderNumber,\nAVG(SalesAmount) as Avg_SalesAmount\nfrom dbo.FactSales_new\ngroup by OrderDateKey\nhaving AVG(SalesAmount) > 1200\nGO\nInsert into #temp EXEC SP_ResultSet\nGO\nselect * from #temp\n\ndrop PROCEDURE dbo.SP_ResultSet;\n\n/*\nStored procedures can be called from other stored procedures, and these are called nested \nstored procedures. We can create nested stored procedures for up to 32 levels. As with \nSQL Server, you can create a nested stored procedure in a SQL pool as well. \n*/\n\n--Nested stored procedures\n/*\nThere could be various levels of nested stored procedures. However, a SQL pool supports \na maximum of eight nesting levels, whereas SQL Server supports a maximum of eight \nnesting levels.\n*/\nCREATE PROCEDURE usp_NestingProcDemo1\nAS\nSELECT 'This is NestingProcDemo1'\nGO\nCREATE PROCEDURE Usp_nestingprocdemo2 \nAS \n  BEGIN\n   SELECT 'Calling from usp_NestingProcDemo2' \n      EXEC Usp_nestingprocdemo1 \n  END\nGO\nEXEC Usp_nestingprocdemo2\n\n--drop PROCEDURE dbo.usp_NestingProcDemo1;\n--drop PROCEDURE dbo.usp_NestingProcDemo2;\n\n/*\nAlthough a SQL pool allows you to create and use stored procedures, it restricts you from \nusing certain aspects of T-SQL stored procedures, such as the following: \n*  Temporary stored procedures\n*  Numbered stored procedures\n*  Extended stored procedures\n*  Common Language Runtime (CLR) stored procedures\n*  Encryption options\n*  Replication options\n*  Table-valued parameters\n*  Read-only parameters\n*  Default parameters\n*  Execution contexts\n*  Return statements\n*/\n\n--Views\n/*Views create a virtual table consisting of a set of named columns and rows of data. \nSynapse SQL allows you to CREATE, ALTER, and DROP your views\n*/\nCREATE VIEW dbo.SampleViewWithEncryption \nAS\nSELECT \n   [OrderDateKey], \n   [SalesOrderNumber], \n   SUM(SalesAmount) as Total_SaleAmount \nFROM dbo.FactSales_new\nGROUP BY ROLLUP(OrderDateKey, SalesOrderNumber)\n\nselect * from dbo.SampleViewWithEncryption\n\n/*\nSynapse serverless SQL allows you to create views as below. If you have an external data source, we can use the OPENROWSET function \nDATA_SOURCE and its relative file path\n*/\nDROP VIEW IF EXISTS [dbo].[populationView]\nGO\nCREATE VIEW populationView AS\nSELECT * \nFROM OPENROWSET(\n        BULK 'https://myadlsaccount1984sa.dfs.core.windows.net/bronze/Covid19csvTestDemo/cases_deaths.csv',\n        FORMAT = 'CSV',\n        HEADER_ROW = True,\n        PARSER_VERSION = '2.0',\n        FIELDTERMINATOR =',', \n        ROWTERMINATOR = '\\n'\n    )\nWITH (\n    [country] VARCHAR (100) COLLATE Latin1_General_100_BIN2_UTF8,\n    [country_code] VARCHAR (20) COLLATE Latin1_General_100_BIN2_UTF8,\n    [continent] VARCHAR (100) COLLATE Latin1_General_100_BIN2_UTF8,\n    [population] BIGINT,\n    [indicator] VARCHAR(200) COLLATE Latin1_General_100_BIN2_UTF8,\n    [daily_count] INT,\n    [date] VARCHAR(20) COLLATE Latin1_General_100_BIN2_UTF8,\n    [rate_14_day] FLOAT,\n    [source] VARCHAR(200) COLLATE Latin1_General_100_BIN2_UTF8\n) AS [r]\nGO\nselect * from [dbo].[populationView]\n\n/*\nOnce the view is created, we can query the data directly without worrying about copying the data to any relational table\n*/\nGO\nselect * from [dbo].[populationView]\n\n--Optimizing transactions in Synapse SQL\n/*\na group of data modification operations is called a transaction. If all operations are successful, we can call it a successful transaction. \nIn a successful transaction, all the modifications are committed and become a permanent part of the database; otherwise, all the data \nmodifications will be erased.\nIn the case of any failure, you will need to roll back all the changes made during the execution of stored procedures in order to maintain \nconsistency in your data. You can handle any sort of exceptions in stored procedures using a TRY-CATCH block as\n*/\nSET NOCOUNT ON;\nDECLARE @xact_state smallint = 0;\nBEGIN TRAN\n    BEGIN TRY\n        DECLARE @i INT;\n        SET @i = @i + 1\n        SET @i = 'ABC' --if we uncomment this statement, we will encounter an exception\n    END TRY\n    BEGIN CATCH\n        SET @xact_state = XACT_STATE();\n        IF @@TRANCOUNT > 0\n            BEGIN \n                ROLLBACK TRAN;\n                PRINT 'ROLLBACK';\n            END\n            SELECT ERROR_NUMBER() AS ErrNumber\n            ,      ERROR_SEVERITY() AS ErrSeverity\n            ,      ERROR_STATE() AS ErrState \n            ,      ERROR_PROCEDURE() AS ErrProcedure \n            ,      ERROR_MESSAGE() AS ErrMessage;\n    END CATCH;\n\nIF @@TRANCOUNT >0\nBEGIN\n    PRINT 'COMMIT';\n    COMMIT TRAN;\nEND\nSELECT @xact_state AS TransactionState;\n\n/*\nIn the preceding code block, if you uncomment SET @i='ABC' you will encounter an error message, and the TransactionStatus value will be -2. \nYou can use a XACT_STATE() function to know the status of a transaction; in the case of a successful transaction its value will be 0, \nand in the case of any failure, its value will be -2. \n*/\n\n/*\nThe following example uses XACT_STATE in the CATCH block of a TRY...CATCH construct to determine whether to commit or roll back a transaction. \nBecause SET XACT_ABORT is ON, the constraint violation error causes the transaction to enter an uncommittable state.\n*/\n\ninsert into dbo.DimSalesRegion (Region)\nselect 'East'\nunion all\nselect 'West'\nunion all\nselect 'North'\nunion all\nselect 'South'\n\n--truncate table dbo.DimSalesRegion;\nselect * from dbo.DimSalesRegion\n\n--USE synapsesqlpool84;\n--GO\n  \n-- SET XACT_ABORT ON will render the transaction uncommittable  \n-- when the constraint violation occurs.  \nSET XACT_ABORT ON;\n\nBEGIN TRY  \n    BEGIN TRANSACTION;  \n        -- A FOREIGN KEY constraint exists on this table. This   \n        -- statement will generate a constraint violation error.  \n        UPDATE dbo.DimSalesRegion  \n            SET RegionID = 10011\n            WHERE Region = 'South';  \n  \n    -- If the delete operation succeeds, commit the transaction. The CATCH  \n    -- block will not execute.  \n    COMMIT TRANSACTION;  \nEND TRY  \nBEGIN CATCH  \n    -- Test XACT_STATE for 0, 1, or -1.  \n    -- If 1, the transaction is committable.  \n    -- If -1, the transaction is uncommittable and should   \n    --     be rolled back.  \n    -- XACT_STATE = 0 means there is no transaction and  \n    --     a commit or rollback operation would generate an error.  \n  \n    -- Test whether the transaction is uncommittable.  \n    IF (XACT_STATE()) = -1  \n    BEGIN  \n        PRINT 'The transaction is in an uncommittable state.' +  \n              ' Rolling back transaction.'  \n        ROLLBACK TRANSACTION;  \n    END;  \n  \n    -- Test whether the transaction is active and valid.  \n    IF (XACT_STATE()) = 1  \n    BEGIN  \n        PRINT 'The transaction is committable.' +   \n              ' Committing transaction.'  \n        COMMIT TRANSACTION;  \n    END;\nEND CATCH;  \nGO\n\nselect XACT_STATE() AS TransactionState;\n\n/*\nA SQL pool implements Atomic, Consistent, Isolated, and Durable (ACID) transactions with read uncommitted as the default isolation. \nRun the following command to check if your SQL pool has a read committed snapshot isolation level:\n*/\nSELECT name, is_read_committed_snapshot_on\nFROM sys.databases\nWHERE name = DB_NAME();\n\n--You can change it to a read committed snapshot isolation by running the following script when connected to the master database:\nALTER DATABASE synapsesqlpool84\nSET READ_COMMITTED_SNAPSHOT ON\nGO\n\n-- To verify various database properties\n--select * from sys.databases",
			"metadata": {
				"language": "sql"
			},
			"currentConnection": {
				"databaseName": "synapsesqlpool84",
				"poolName": "synapsesqlpool84"
			},
			"resultLimit": 5000
		},
		"type": "SqlQuery"
	}
}