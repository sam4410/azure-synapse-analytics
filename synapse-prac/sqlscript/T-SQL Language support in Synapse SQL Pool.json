{
	"name": "T-SQL Language support in Synapse SQL Pool",
	"properties": {
		"content": {
			"query": "/*The SELECT statement in T-SQL retrieves rows from a database and enables the selection \nof columns and rows from one or multiple tables in Azure Synapse SQL. You can use the SELECT \nstatement with WHERE, GROUP BY, HAVING, and ORDER BY clauses in dedicated and serverless SQL pools.\nThe syntax for the SELECT statement in Synapse SQL is similar to that found in Azure SQL Database \nor SQL Server.\n*/\n\n/*\nSELECT OrderDateKey, SUM(SalesAmount) AS TotalSales \nFROM FactInternetSales \nGROUP BY OrderDateKey \nHAVING OrderDateKey > 20010000 \nORDER BY OrderDateKey;\n*/\n\n--CTEs\n/*A CTE is a temporary result set that is used to simplify complex joins and subqueries\nCTEs can also be used to query hierarchical data such as an organization chart. We can \neven create CTEs in Azure Synapse SQL pools for similar operations.\nThe following code block defines a CTE that will create a temporary dataset called CTE\nwith first_name and last_name columns derived from a UserData table. The SELECT query against this \ntemporary dataset will fetch all the records\n*/\n\ninsert into dbo.UserData (registration_dttm, id, first_name, last_name, email, gender,ip_address, cc,\ncountry, birthdate, salary, title, comments)\nvalues('2021-01-10 12:15:18.333', 123, 'Manoj', 'Sharma','sharma.manoj84@yahoo.co.in','Male','10.0.10.36.0',\n'201304611451200','India','1984-06-19', 2000.5, 'Tech Lead','Null')\n\nWITH CTE (id, first_name, last_name)\nAS (\n    SELECT U.[id],\n    [first_name],\n    [last_name]\n    FROM dbo.[UserData] U\n)\nSELECT * from CTE;\n\n-- SELECT-OVER Clause\n/*\nAn OVER clause is used with some window functions.  It is used to determine the partitioning and \nordering of a set of rows before the associated window function is applied.\nThe associated window function is applied on this set of rows to compute a value as per the business \ndemand. A few of the most commonly used calculations are moving averages, cumulative aggregates, \nand running totals, among others\n*/\n\n--Ranking functions\n/*\nRanking functions are used to assign a rank to each row in a partition or set of rows and \nreturn an aggregated value for each partitioning row. Ranking functions are also known as \nwindow functions.\nWe can use RANK, DENSE_RANK, ROW_NUMBER, and NTILE ranking functions in Azure Synapse SQL.\n1. The RANK function returns 1 plus the number of ranks that come before the row in \nquestion, and it provides the same numeric values for ties.\n2.  ROW_NUMBER is used to get the temporary unique sequential number of a row \nwithin a partition of a result set. It assigns rank one for the first row and increments \nthe value by 1 for each row; even if a row has similar values, it will still get assigned \na unique number.\n3. DENSE_RANK is similar to the RANK function, with a minor difference: it assigns \nthe same rank for duplicate or similar values.\n4. The NTILE function is used to divide records into a specified number of groups, \nand each group will be assigned a rank as per the specified condition. We need to \nspecify the number of groups as a parameter value to the NTILE functionâ€”for \nexample, NTILE(2)\n*/\n\nSELECT p.FirstName, p.LastName \n    , ROW_NUMBER() OVER(PARTITION BY PostalCode ORDER BY \nSalesYTD DESC) AS \"Row Number\"\n    ,RANK() OVER (ORDER BY a.PostalCode) AS Rank  \n    ,DENSE_RANK() OVER (ORDER BY a.PostalCode) AS \"Dense Rank\"  \n    ,NTILE(4) OVER (ORDER BY a.PostalCode) AS Quartile\n     ,s.SalesYTD  \n    ,a.PostalCode  \nFROM Sales.SalesPerson AS s   \n    INNER JOIN Person.Person AS p   \n        ON s.BusinessEntityID = p.BusinessEntityID  \n    INNER JOIN Person.Address AS a   \n        ON a.AddressID = p.BusinessEntityID  \nWHERE TerritoryID IS NOT NULL AND SalesYTD <> 0;\n\n--Aggregate functions\n/*\nAggregate functions are used to perform a calculation on a set of values such that it \nreturns a single aggregated value. Aggregate functions can be used as expressions in the \nselect list of a SELECT statement or with a HAVING clause.\nT-SQL provides various aggregate functions, such as MIN, MAX, SUM, COUNT, AVG, and \nmany more.\nMost of these functions can even be used with an OVER clause to get the aggregated value \nfor each group in the returned row set.\n*/\n\nSELECT DISTINCT Name  \n       , MIN(Rate) OVER (PARTITION BY edh.DepartmentID) AS \nMinSalary\n, MAX(Rate) OVER (PARTITION BY edh.DepartmentID) AS \nMaxSalary  \n       , AVG(Rate) OVER (PARTITION BY edh.DepartmentID) AS \nAvgSalary  \n       ,COUNT(edh.BusinessEntityID) OVER (PARTITION BY edh.\nDepartmentID) AS EmployeesPerDept  \nFROM HumanResources.EmployeePayHistory AS eph  \nJOIN HumanResources.EmployeeDepartmentHistory AS edh  \n     ON eph.BusinessEntityID = edh.BusinessEntityID  \nJOIN HumanResources.Department AS d  \n ON d.DepartmentID = edh.DepartmentID  \nWHERE edh.EndDate IS NULL  \nORDER BY Name;\n\n--Analytic functions\n/*\nAnalytic functions are used in various different ways to perform calculations on the data \nstored in a Synapse SQL pool. We can use these functions to get top-N results or to perform \naggregate operations within a group. These functions can return multiple rows for each group.\nAzure Synapse SQL supports the following analytic functions:\n1.  CUME_DIST: This function can be used when you want to know the relative \nposition of a specific value within a group of values\n2.  FIRST_VALUE: We can use this function to get the first value in an ordered set \nof values.\n3.  LAG: Using the LAG function, you can access a row at a given physical offset that \ncomes before the current row.\n4.  LAST_VALUE: Similar to FIRST_VALUE, we can use the LAST_VALUE function to \nget the last value in an ordered set of values.\n5.  LEAD: Using the LEAD function, you can access a row at a given physical offset that \ncomes after the current row\n*/\n\n--Using dynamic SQL in Synapse SQL\n/*\nAlthough in most situations static SQL statements work well, there could be certain situations \nwhen we need to use dynamic SQL statements. Dynamic SQL is a programming technique applied to \nframe SQL statements at runtime.\nYou can use sp_executesql to run dynamic SQL scripts\n*/\n\nDECLARE @sql_fragment NVARCHAR(1000)='SELECT * from dbo.UserData1'\nEXECUTE sp_executesql @sql_fragment\n\n/*\nA SQL pool does not support blob data types that include both VARCHAR(MAX) and \nNVARCHAR(MAX). Because of this limitation, you may have difficulty in building a large \ndynamic SQL string; however, you can break the code into chunks and concatenate all the \nchunks together with an EXEC statement, as follows:\n*/\nDECLARE @sql_fragment1 VARCHAR(8000)=' SELECT name '\n,       @sql_fragment2 VARCHAR(8000)=' FROM sys.system_views '\n,       @sql_fragment3 VARCHAR(8000)=' WHERE name like \n''%table%''';\nEXEC( @sql_fragment1 + @sql_fragment2 + @sql_fragment3);\n\n/*\nThe preceding code block has three different SQL statements that are assigned to three \ndifferent variables: sql_fragment1, sql_fragment2, and sql_fragment3. \nIn the end, all the SQL statements are concatenated by using the + sign, and then the \nconsolidated SQL statement is executed by using an EXEC statement.\nDynamic SQL statements can be used in situations where you need to run similar SQL \nstatements multiple times with minor changes in the statement.\nHowever, GROUP BY is not supported with CUBE in an Azure Synapse SQL pool. We will \nlearn about the workarounds further on in this section.\n*/\n\n--GROUP BY options in Synapse SQL\n/*\nA GROUP BY clause is used with a SELECT statement to arrange identical data into groups.\nA GROUP BY clause can be used when we need to use aggregate functions such as SUM, \nAVG, and so on to fetch the aggregated value of a grouped set of records. GROUP BY can \nalso be used with CUBE, ROLLUP, and GROUPING SETS.\n*/\nselect Year, Make, sum(Trade_1_Actual_Cash_Value) as actual_cash_val\nfrom dbo.authenticom_sales\ngroup by Year, Make;\n\n--use GROUP BY with a HAVING clause to filter the data\nselect Year, Make, sum(Trade_1_Actual_Cash_Value) as Trade_1_Actual_Cash_Val\nfrom dbo.authenticom_sales\ngroup by Year, Make\nhaving sum(Trade_1_Actual_Cash_Value) <> 0 and Year >= 2000\norder by Year, Make;\n\n/*\ncalculate the aggregated value on individual groups and the cumulative aggregated value together, GROUP BY ROLLUP can be \nused with a SELECT statement\n*/\nselect Year, Make, sum(Trade_1_Actual_Cash_Value) as actual_cash_val\nfrom dbo.authenticom_sales\ngroup by rollup(Year, Make);\n\n--Using T-SQL loops in Synapse SQL\n/*\nAzure Synapse SQL allows you to use a WHILE loop to execute statements repeatedly, as long as the specified condition is True.\n*/\nDECLARE @i INT=1\nWHILE(@i<5)\n             BEGIN\n                        SELECT @i \n                        /*Your logic goes here*/\n                         SET @i+=1\n            END\n\n--We can control WHILE loops by inserting a BREAK keyword inside the loop\nWHILE (SELECT AVG(Trade_1_Actual_Cash_Value) FROM dbo.authenticom_sales) < 1000\nBEGIN\nUPDATE dbo.authenticom_sales\n    SET Trade_1_Actual_Cash_Value = Trade_1_Actual_Cash_Value*2\nSELECT MAX(Trade_1_Actual_Cash_Value) FROM dbo.authenticom_sales\n    IF (SELECT MAX(Trade_1_Actual_Cash_Value) FROM dbo.authenticom_sales) > 5000\n    BREAK\nEND\n\n--Creating stored procedures and views in Synapse SQL\n--Stored procedures\n/*\nA stored procedure is prepared SQL code that can be saved and reused. One important \nthing to keep in mind is that stored procedures are not precompiled in a Synapse SQL \npool. When stored procedures are executed, SQL statements are parsed, translated, and \noptimized at runtime. As with SQL Server, you can pass parameters to stored procedures \nin a SQL pool as well.\n*/\nINSERT INTO dbo.FactSales_new (SalesID, OrderDateKey, CustomerKey, PromotionKey, ProductKey, \nSalesOrderNumber, OrderQuantity, UnitPrice, SalesAmount) VALUES (3, 12013, 9, 7, 10, 'S_003', 20, 30, 600)\n\nALTER PROCEDURE Usp_samplestoredprocedure (@MinPriceCondition \nMONEY, \n                                      @MaxPriceCondition MONEY) \nAS \n  BEGIN \n      WHILE (SELECT AVG(SalesAmount)\n      FROM   dbo.FactSales_new) < @MinPriceCondition \n        BEGIN \n            UPDATE dbo.FactSales_new\n            SET SalesAmount = SalesAmount * 2 \n            SELECT MAX(SalesAmount) \n            FROM dbo.FactSales_new \n            IF (SELECT MAX(SalesAmount) \n                FROM dbo.FactSales_new) > @MaxPriceCondition \n              BREAK \n        END \n  END\n\nEXEC dbo.Usp_samplestoredprocedure\n@MinPriceCondition = 2000,\n@MaxPriceCondition = 5000;\n\nselect * from dbo.FactSales_new\n\n--You can consume the result set of a stored procedure with an INSERT statement in a SQL pool\n\n",
			"metadata": {
				"language": "sql"
			},
			"currentConnection": {
				"databaseName": "synapsesqlpool84",
				"poolName": "synapsesqlpool84"
			},
			"resultLimit": 5000
		},
		"type": "SqlQuery"
	}
}