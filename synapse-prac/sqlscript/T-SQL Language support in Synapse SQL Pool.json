{
	"name": "T-SQL Language support in Synapse SQL Pool",
	"properties": {
		"content": {
			"query": "/*The SELECT statement in T-SQL retrieves rows from a database and enables the selection \nof columns and rows from one or multiple tables in Azure Synapse SQL. You can use the SELECT \nstatement with WHERE, GROUP BY, HAVING, and ORDER BY clauses in dedicated and serverless SQL pools.\nThe syntax for the SELECT statement in Synapse SQL is similar to that found in Azure SQL Database \nor SQL Server.\n*/\n\n/*\nSELECT OrderDateKey, SUM(SalesAmount) AS TotalSales \nFROM FactInternetSales \nGROUP BY OrderDateKey \nHAVING OrderDateKey > 20010000 \nORDER BY OrderDateKey;\n*/\n\n--CTEs\n/*A CTE is a temporary result set that is used to simplify complex joins and subqueries\nCTEs can also be used to query hierarchical data such as an organization chart. We can \neven create CTEs in Azure Synapse SQL pools for similar operations.\nThe following code block defines a CTE that will create a temporary dataset called CTE\nwith first_name and last_name columns derived from a UserData table. The SELECT query against this \ntemporary dataset will fetch all the records\n*/\n\ninsert into dbo.UserData (registration_dttm, id, first_name, last_name, email, gender,ip_address, cc,\ncountry, birthdate, salary, title, comments)\nvalues('2021-01-10 12:15:18.333', 123, 'Manoj', 'Sharma','sharma.manoj84@yahoo.co.in','Male','10.0.10.36.0',\n'201304611451200','India','1984-06-19', 2000.5, 'Tech Lead','Null')\n\nWITH CTE (id, first_name, last_name)\nAS (\n    SELECT U.[id],\n    [first_name],\n    [last_name]\n    FROM dbo.[UserData] U\n)\nSELECT * from CTE;\n\n-- SELECT-OVER Clause\n/*\nAn OVER clause is used with some window functions.  It is used to determine the partitioning and \nordering of a set of rows before the associated window function is applied.\nThe associated window function is applied on this set of rows to compute a value as per the business \ndemand. A few of the most commonly used calculations are moving averages, cumulative aggregates, \nand running totals, among others\n*/\n\n--Ranking functions\n/*\nRanking functions are used to assign a rank to each row in a partition or set of rows and \nreturn an aggregated value for each partitioning row. Ranking functions are also known as \nwindow functions.\nWe can use RANK, DENSE_RANK, ROW_NUMBER, and NTILE ranking functions in Azure Synapse SQL.\n1. The RANK function returns 1 plus the number of ranks that come before the row in \nquestion, and it provides the same numeric values for ties.\n2.  ROW_NUMBER is used to get the temporary unique sequential number of a row \nwithin a partition of a result set. It assigns rank one for the first row and increments \nthe value by 1 for each row; even if a row has similar values, it will still get assigned \na unique number.\n3. DENSE_RANK is similar to the RANK function, with a minor difference: it assigns \nthe same rank for duplicate or similar values.\n4. The NTILE function is used to divide records into a specified number of groups, \nand each group will be assigned a rank as per the specified condition. We need to \nspecify the number of groups as a parameter value to the NTILE functionâ€”for \nexample, NTILE(2)\n*/\n\nSELECT p.FirstName, p.LastName \n    , ROW_NUMBER() OVER(PARTITION BY PostalCode ORDER BY \nSalesYTD DESC) AS \"Row Number\"\n    ,RANK() OVER (ORDER BY a.PostalCode) AS Rank  \n    ,DENSE_RANK() OVER (ORDER BY a.PostalCode) AS \"Dense Rank\"  \n    ,NTILE(4) OVER (ORDER BY a.PostalCode) AS Quartile\n     ,s.SalesYTD  \n    ,a.PostalCode  \nFROM Sales.SalesPerson AS s   \n    INNER JOIN Person.Person AS p   \n        ON s.BusinessEntityID = p.BusinessEntityID  \n    INNER JOIN Person.Address AS a   \n        ON a.AddressID = p.BusinessEntityID  \nWHERE TerritoryID IS NOT NULL AND SalesYTD <> 0;\n\n--Aggregate functions\n/*\nAggregate functions are used to perform a calculation on a set of values such that it \nreturns a single aggregated value. Aggregate functions can be used as expressions in the \nselect list of a SELECT statement or with a HAVING clause.\nT-SQL provides various aggregate functions, such as MIN, MAX, SUM, COUNT, AVG, and \nmany more.\nMost of these functions can even be used with an OVER clause to get the aggregated value \nfor each group in the returned row set.\n*/\n\nSELECT DISTINCT Name  \n       , MIN(Rate) OVER (PARTITION BY edh.DepartmentID) AS \nMinSalary\n, MAX(Rate) OVER (PARTITION BY edh.DepartmentID) AS \nMaxSalary  \n       , AVG(Rate) OVER (PARTITION BY edh.DepartmentID) AS \nAvgSalary  \n       ,COUNT(edh.BusinessEntityID) OVER (PARTITION BY edh.\nDepartmentID) AS EmployeesPerDept  \nFROM HumanResources.EmployeePayHistory AS eph  \nJOIN HumanResources.EmployeeDepartmentHistory AS edh  \n     ON eph.BusinessEntityID = edh.BusinessEntityID  \nJOIN HumanResources.Department AS d  \n ON d.DepartmentID = edh.DepartmentID  \nWHERE edh.EndDate IS NULL  \nORDER BY Name;\n\n--Analytic functions\n/*\nAnalytic functions are used in various different ways to perform calculations on the data \nstored in a Synapse SQL pool. We can use these functions to get top-N results or to perform \naggregate operations within a group. These functions can return multiple rows for each group.\nAzure Synapse SQL supports the following analytic functions:\n1.  CUME_DIST: This function can be used when you want to know the relative \nposition of a specific value within a group of values\n2.  FIRST_VALUE: We can use this function to get the first value in an ordered set \nof values.\n3.  LAG: Using the LAG function, you can access a row at a given physical offset that \ncomes before the current row.\n4.  LAST_VALUE: Similar to FIRST_VALUE, we can use the LAST_VALUE function to \nget the last value in an ordered set of values.\n5.  LEAD: Using the LEAD function, you can access a row at a given physical offset that \ncomes after the current row\n*/\n\n--Using dynamic SQL in Synapse SQL\n/*\nAlthough in most situations static SQL statements work well, there could be certain situations \nwhen we need to use dynamic SQL statements. Dynamic SQL is a programming technique applied to \nframe SQL statements at runtime.\nYou can use sp_executesql to run dynamic SQL scripts\n*/\n\nDECLARE @sql_fragment NVARCHAR(1000)='SELECT * from dbo.UserData1'\nEXECUTE sp_executesql @sql_fragment\n\n/*\nA SQL pool does not support blob data types that include both VARCHAR(MAX) and \nNVARCHAR(MAX). Because of this limitation, you may have difficulty in building a large \ndynamic SQL string; however, you can break the code into chunks and concatenate all the \nchunks together with an EXEC statement, as follows:\n*/\nDECLARE @sql_fragment1 VARCHAR(8000)=' SELECT name '\n,       @sql_fragment2 VARCHAR(8000)=' FROM sys.system_views '\n,       @sql_fragment3 VARCHAR(8000)=' WHERE name like \n''%table%''';\nEXEC( @sql_fragment1 + @sql_fragment2 + @sql_fragment3);\n\n/*\nThe preceding code block has three different SQL statements that are assigned to three \ndifferent variables: sql_fragment1, sql_fragment2, and sql_fragment3. \nIn the end, all the SQL statements are concatenated by using the + sign, and then the \nconsolidated SQL statement is executed by using an EXEC statement.\nDynamic SQL statements can be used in situations where you need to run similar SQL \nstatements multiple times with minor changes in the statement\n*/\n\n--GROUP BY options in Synapse SQL\n",
			"metadata": {
				"language": "sql"
			},
			"currentConnection": {
				"databaseName": "synapsesqlpool84",
				"poolName": "synapsesqlpool84"
			},
			"resultLimit": 5000
		},
		"type": "SqlQuery"
	}
}